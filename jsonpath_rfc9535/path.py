"""A compiled JSONPath ready to be applied to JSON-like data."""

from __future__ import annotations

from typing import TYPE_CHECKING
from typing import Any
from typing import Dict
from typing import Iterable
from typing import List
from typing import Tuple
from typing import Union

from .node import JSONPathNode
from .node import JSONPathNodeList
from .segments import JSONPathRecursiveDescentSegment
from .selectors import IndexSelector
from .selectors import PropertySelector

if TYPE_CHECKING:
    from .environment import JSONPathEnvironment
    from .segments import JSONPathSegment


class JSONPath:
    """A compiled JSONPath ready to be applied to JSON-like data.

    Arguments:
        env: The `JSONPathEnvironment` this path is bound to.
        segments: An iterable of `JSONPathSelector` objects, as generated by
            a `Parser`.

    Attributes:
        env: The `JSONPathEnvironment` this path is bound to.
        segments: The `JSONPathSelector` instances that make up this path.
    """

    __slots__ = ("env", "fake_root", "segments")

    def __init__(
        self,
        *,
        env: JSONPathEnvironment,
        segments: Tuple[JSONPathSegment, ...],
    ) -> None:
        self.env = env
        self.segments = segments

    def __str__(self) -> str:
        return "$" + "".join(str(segment) for segment in self.segments)

    def __hash__(self) -> int:
        return hash(self.segments)

    def finditer(
        self,
        data: Union[List[Any], Dict[str, Any], str],
    ) -> Iterable[JSONPathNode]:
        """Generate `JSONPathNode` instances for each match of this path in _data_.

        Arguments:
            data: JSON-like data to query, as you'd get from `json.load`.

        Returns:
            An iterator yielding `JSONPathNode` objects for each match.

        Raises:
            JSONPathSyntaxError: If the path is invalid.
            JSONPathTypeError: If a filter expression attempts to use types in
                an incompatible way.
        """
        nodes: Iterable[JSONPathNode] = [
            JSONPathNode(
                value=data,
                parts=(),
                root=data,
            )
        ]

        for segment in self.segments:
            nodes = segment.resolve(nodes)

        return nodes

    def findall(
        self,
        data: Union[List[Any], Dict[str, Any], str],
    ) -> List[object]:
        """Find all values in _data_ matching this JSONPath.

        Arguments:
            data: JSON-like data to query, as you'd get from `json.load`.

        Returns:
            A list of matched values. If there are no matches, the list will be empty.

        Raises:
            JSONPathSyntaxError: If the path is invalid.
            JSONPathTypeError: If a filter expression attempts to use types in
                an incompatible way.
        """
        return [node.value for node in self.finditer(data)]

    def query(
        self,
        data: Union[List[Any], Dict[str, Any], str],
    ) -> JSONPathNodeList:
        """Apply this JSONPath query to JSON-like _data_ and return a node list.

        Arguments:
            data: JSON-like data to query, as you'd get from `json.load`.

        Returns:
            A list of `JSONPathNode` instance.

        Raises:
            JSONPathSyntaxError: If the path is invalid.
            JSONPathTypeError: If a filter expression attempts to use types in
                an incompatible way.
        """
        return JSONPathNodeList(self.finditer(data))

    def singular_query(self) -> bool:
        """Return `True` if this JSONPath query is a singular query."""
        for segment in self.segments:
            if isinstance(segment, JSONPathRecursiveDescentSegment):
                return False

            if len(segment.selectors) == 1 and isinstance(
                segment.selectors[0], (PropertySelector, IndexSelector)
            ):
                continue

            return False

        return True

    def empty(self) -> bool:
        """Return `True` if this path has no segments."""
        return not bool(self.segments)
