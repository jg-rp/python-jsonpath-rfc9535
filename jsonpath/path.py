"""A compiled JSONPath ready to be applied to JSON-like data."""

from __future__ import annotations

from typing import TYPE_CHECKING
from typing import Any
from typing import Iterable
from typing import Mapping
from typing import Sequence
from typing import Union

from .node import JSONPathNode
from .selectors import IndexSelector
from .selectors import PropertySelector

if TYPE_CHECKING:
    from .environment import JSONPathEnvironment
    from .segments import JSONPathSegment


class JSONPath:
    """A compiled JSONPath ready to be applied to JSON-like data.

    Arguments:
        env: The `JSONPathEnvironment` this path is bound to.
        segments: An iterable of `JSONPathSelector` objects, as generated by
            a `Parser`.

    Attributes:
        env: The `JSONPathEnvironment` this path is bound to.
        segments: The `JSONPathSelector` instances that make up this path.
    """

    __slots__ = ("env", "fake_root", "segments")

    def __init__(
        self,
        *,
        env: JSONPathEnvironment,
        segments: Iterable[JSONPathSegment],
    ) -> None:
        self.env = env
        self.segments = tuple(segments)

    def __str__(self) -> str:
        return "$" + "".join(str(segment) for segment in self.segments)

    def __hash__(self) -> int:
        return hash(self.segments)

    def query(
        self,
        data: Union[Sequence[Any], Mapping[str, Any]],
    ) -> Iterable[JSONPathNode]:
        """Apply this JSONPath query to JSON-like data, _data_.

        Arguments:
            data: A Python object implementing the `Sequence` or `Mapping` interfaces.

        Returns:
            An iterator yielding `JSONPathMatch` objects for each match.

        Raises:
            JSONPathSyntaxError: If the path is invalid.
            JSONPathTypeError: If a filter expression attempts to use types in
                an incompatible way.
        """
        nodes: Iterable[JSONPathNode] = [
            JSONPathNode(
                value=data,
                location=(),
                root=data,
            )
        ]

        for segment in self.segments:
            nodes = segment.resolve(nodes)

        return nodes

    def singular_query(self) -> bool:
        """Return `True` if this JSONPath query is a singular query."""
        for segment in self.segments:
            if len(segment.selectors) == 1 and isinstance(
                segment.selectors[0], (PropertySelector, IndexSelector)
            ):
                continue
            return False
        return True

    def empty(self) -> bool:
        """Return `True` if this path has no segments."""
        return not bool(self.segments)
